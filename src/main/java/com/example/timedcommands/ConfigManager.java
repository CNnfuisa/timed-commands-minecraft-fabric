package com.example.timedcommands;

import net.fabricmc.loader.api.FabricLoader;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.constructor.Constructor;
import org.yaml.snakeyaml.nodes.Tag;
import org.yaml.snakeyaml.representer.Representer;
import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.LoaderOptions;

import java.io.*;
import java.nio.file.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class ConfigManager {
    private static final Yaml YAML;
    private static final Path CONFIG_PATH = FabricLoader.getInstance().getConfigDir().resolve("timed_commands.yaml");
    
    static {
        // Configure SnakeYAML to handle our classes properly
        DumperOptions dumperOptions = new DumperOptions();
        dumperOptions.setIndent(2);
        dumperOptions.setPrettyFlow(false);
        dumperOptions.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
        dumperOptions.setDefaultScalarStyle(DumperOptions.ScalarStyle.DOUBLE_QUOTED); // Ensure all strings are quoted
        
        Representer representer = new Representer(dumperOptions);
        representer.addClassTag(Config.class, Tag.MAP);
        representer.addClassTag(Config.Global.class, Tag.MAP);
        representer.addClassTag(TimedTask.class, Tag.MAP);
        
        LoaderOptions loaderOptions = new LoaderOptions();
        Constructor constructor = new Constructor(Config.class, loaderOptions);
        YAML = new Yaml(constructor, representer, dumperOptions, loaderOptions);
    }
    
    private Config config;
    private WatchService watchService;
    private ExecutorService watchExecutor;
    private volatile boolean running = true;
    
    public ConfigManager() {
        this.config = new Config();
        
        // Set up file watcher for config changes
        try {
            watchService = FileSystems.getDefault().newWatchService();
            CONFIG_PATH.getParent().register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);
            
            watchExecutor = Executors.newSingleThreadExecutor();
            watchExecutor.execute(this::watchConfigFile);
        } catch (IOException e) {
            TimedCommandMod.LOGGER.error("Failed to set up config file watcher: {}", e.getMessage());
        }
    }
    
    public synchronized void loadConfig() {
        try {
            if (Files.exists(CONFIG_PATH)) {
                TimedCommandMod.LOGGER.info("Loading config from: {}", CONFIG_PATH);
                try (Reader reader = Files.newBufferedReader(CONFIG_PATH)) {
                    Config newConfig = YAML.load(reader);
                    if (newConfig != null) {
                        this.config = newConfig;
                        TimedCommandMod.LOGGER.info("Successfully loaded config with {} tasks", config.getTasks().size());
                    } else {
                        TimedCommandMod.LOGGER.error("Failed to load config: Config is null");
                        this.config = new Config();
                    }
                }
            } else {
                TimedCommandMod.LOGGER.info("Config file not found, generating default config...");
                saveConfig();
            }
        } catch (IOException e) {
            TimedCommandMod.LOGGER.error("Failed to load config: {}", e.getMessage());
            this.config = new Config();
        } catch (Exception e) {
            TimedCommandMod.LOGGER.error("Failed to parse config: {}", e.getMessage());
            this.config = new Config();
        }
    }
    
    public synchronized void saveConfig() {
        try {
            Files.createDirectories(CONFIG_PATH.getParent());
            try (Writer writer = Files.newBufferedWriter(CONFIG_PATH)) {
                // Write header comment
                writer.write("# Timed Commands Mod Configuration\n");
                writer.write("# This file is automatically generated if it doesn't exist\n");
                writer.write("# You can add multiple tasks, each with its own time and commands\n");
                writer.write("# Time format: HH:mm:ss (24-hour format)\n");
                writer.write("# Days format: MON, TUE, WED, THU, FRI, SAT, SUN\n\n");
                
                // Write YAML content
                YAML.dump(config, writer);
            }
            TimedCommandMod.LOGGER.info("Config saved to: {}", CONFIG_PATH);
        } catch (IOException e) {
            TimedCommandMod.LOGGER.error("Failed to save config: {}", e.getMessage());
        }
    }
    
    private void watchConfigFile() {
        try {
            while (running) {
                WatchKey key = watchService.poll(100, TimeUnit.MILLISECONDS);
                if (key != null) {
                    for (WatchEvent<?> event : key.pollEvents()) {
                        if (event.kind() == StandardWatchEventKinds.ENTRY_MODIFY) {
                            Path modifiedFile = CONFIG_PATH.getParent().resolve((Path) event.context());
                            if (modifiedFile.equals(CONFIG_PATH)) {
                                TimedCommandMod.LOGGER.info("Config file modified, reloading...");
                                loadConfig();
                                
                                // Reschedule all tasks after config reload
                                TimedCommandMod instance = TimedCommandMod.getInstance();
                                if (instance != null) {
                                    TimedCommandMod.LOGGER.info("Rescheduling tasks after config update...");
                                    instance.scheduleAllTasks();
                                }
                            }
                        }
                    }
                    key.reset();
                }
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            TimedCommandMod.LOGGER.info("Config file watcher stopped.");
        } catch (Exception e) {
            TimedCommandMod.LOGGER.error("Error in config file watcher: {}", e.getMessage());
        }
    }
    
    public synchronized Config getConfig() {
        return config;
    }
    
    /**
     * Closes all resources, including the watch service and executor.
     */
    public void close() {
        running = false;
        
        // Shutdown the watch executor
        if (watchExecutor != null && !watchExecutor.isShutdown()) {
            watchExecutor.shutdown();
            try {
                if (!watchExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                    watchExecutor.shutdownNow();
                }
            } catch (InterruptedException e) {
                watchExecutor.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }
        
        // Close the watch service
        if (watchService != null) {
            try {
                watchService.close();
            } catch (IOException e) {
                TimedCommandMod.LOGGER.error("Failed to close watch service: {}", e.getMessage());
            }
        }
    }
}